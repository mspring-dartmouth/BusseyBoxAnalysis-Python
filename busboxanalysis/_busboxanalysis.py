import pandas as pd
import numpy as np
import itertools
import re
import scipy


'''
    Functions that are used by other modules in this package. 
'''
#####################################################UTILITY FUNCTIONS###########################################################

def apply_boxcar(input_signal, window=5):
    ''' Applies a boxcar filter to an input signal. This is identical to a moving average filter for the bulk of the signal, but will differ on the tails. 
        :param input_signal: single dimensional input on which to calculate the average. 
        :param window: desired # of points to use in calculation of moving average. Default = 5
        :return normed_cropped_filtfilt: averaged signal
    '''

    cutoff_point = -1*(window-1) # The output signal will be window-1 points longer than the input signal. 
                                 # The final window-1 values of the output do not appear to be related to the input signal. 
                                 # To be fair, the first window-1 also appear to be spurious, but at least they exist? 
                                 # Realistically, I should look into what the shoulders of the filter response are called, 
                                 # and whether there is a better way to apply this. 
    filt_window = scipy.signal.windows.boxcar(window)
    norm_constant = filt_window.sum()
    filt_output = scipy.signal.convolve(input_signal, filt_window)
    normed_cropped_filtfilt = filt_output[:cutoff_point]/norm_constant

    return normed_cropped_filtfilt
    

def moving_average(a, n=5, pad_leading_zeros=True) :
    '''Calculates a moving average on single dimensional input using order "n".
       :param a: single dimensional input on which to calculate average.
       :param n: desired # of points to use in calculation of moving average. Default = 5.
       :param pad_leading_zeros: determines whether zeros will be added to front of output signal so that len(ret) == len(a); else len(ret) == len(a) - n
       :return ret: The moving average.
    '''
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    ret = ret[n - 1:] / n
    if pad_leading_zeros:
        # Pads  with leading zeros to avoid changing array size
        ret = np.insert(ret, 0, np.zeros(n-1))
    else:
        pass
    return ret

def enumerate2(iterable, start=0, step=1):
    '''Identical to built-in enumerate, but enables variation in start and step.
       :param iterable: an iterable which will provide the primary outputs in the loop
       :param start: value at which to begin enumeration
       :param step: amount by which secondary value will increase with each iteration.
       :return None: This is a wrapper function. 
    '''
    for x in iterable:
        yield (start, x)
        start += step

def enumerated_product(*args):
    ''' Similar to enumerate, but performs the iteration across combinations of multiple iterables. 
        Each iteration yields a tuple containing two tuples. The first contains the indices of the values in the second, 
        while the second contains the actual iteration across the iterables provided to args '''
    yield from zip(itertools.product(*(range(len(x)) for x in args)), itertools.product(*args))


'''
    Functions used for reading in raw Bussey-Box generated data files. 
'''
#####################################################FILE I/O FUNCTIONS###########################################################
def read_raw_file(input_file):
    '''
        Reads the data from a single raw output file from ABET-II Bussey-Saksida Boxes.
        :input input_file: A comma separated values file generated by ABET-II through "export to .csv"
        :return raw_data_df: A pandas dataframe that contains session data from input_file in the same
                             format as it exists in input_file (each row is a discrete event)
        :return session_data: A pandas series that contains metadata about the session, pulled from the
                             header section of input_file. Specifically: mouse id, date of run, and box #. 
    '''
    first_col = pd.read_csv(input_file, usecols=['Name'], nrows=50, skip_blank_lines=False)
    data_start_idx = first_col[first_col.Name=='Evnt_Time'].index[0]   
    
    session_info = pd.read_csv(input_file, nrows=data_start_idx-1, index_col=0, on_bad_lines='skip') # This will only cause problems if Animal ID, Date, or Environment are bad.  
    # For earlier versions of pandas replace on_bad_lines = 'skip' with error_bad_lines = False
    mouse_id = session_info.loc['Animal ID', 'Value']
    date = re.search('\d{1,2}/\d{1,2}/\d{4}', session_info.loc['Date/Time', 'Value']).group(0)
    box = session_info.loc['Environment'].values

    session_data = pd.Series(index = ['id', 'date', 'box'],
                             data = [mouse_id, date, box])
    raw_data_df = pd.read_csv(input_file, skiprows=data_start_idx+1)
    return raw_data_df, session_data

def batch_read_files(list_of_paths, use_date_as_key = True, mixup_fixer = None):
    '''
        Executes read_raw_file on a list of provided files. 
        :input list_of_paths: The list of files on which to execute read_raw_file.
        :input use_date_as_key: Toggles whether the output will be organized by run-date within mouse id.
        :input mixup_fixer: An easy way to repair labels if mice were run in the wrong boxes. 
                            It should be formatted as a tuple containing two dictionaries. 
                            mixup_fixer[0] should have key: mouse_id and value: the box that that mouse actually ran in.
                            mixup_fixer[1] should have key: the erroneous mouse id associated with a given box, and
                                                     value: the id of the mouse that actually ran in a given box.
        :return df_dict: a dictionary containing the raw_data_df output of read_raw_file. 
                         If use_date_as_key == True, then the dictionary will be nested. 
                            Key: mouse_id, value: dictionary containing keys: date, value: raw_data_df for mouse_id on date.
                         if use_date_as_key == False, then the dictionary will use mouse_id as the only key.
                         IF DATA FROM A SINGLE MICE ON MULTIPLE DAYS ARE USED WITH USE_DATE_AS_KEY SET TO FALSE,
                         DATA FROM INDIVIDUAL DAYS WILL BE CLOBBERED. 

    '''
    try:
        box_dict, id_switcher = mixup_fixer
        swap_ids = True
    except TypeError:
        swap_ids = False

    df_dict = {}
    for file in list_of_paths:
        data, sess_info = read_raw_file(file)
        mouse_id, date, box = sess_info[['id', 'date', 'box']]
        
        # If the box from sess_info doesn't match the box that the mouse truly ran in, then there's been a mix-up.
        if swap_ids and box != box_dict[mouse_id]: 
            print(f'{mouse_id}--->{id_switcher[mouse_id]} for {date}')
            # Change the mouse id to that of the mouse that actually ran in the given box for the given shift
            # base on the mouse label that erroneously used for the box in a shift.
            mouse_id = id_switcher[mouse_id]

        # Store data or start empty dict for storing dates.
        if mouse_id not in df_dict.keys():
            df_dict[mouse_id] = {} if use_date_as_key else data
               
        if use_date_as_key:
            df_dict[mouse_id][date] = data

    return df_dict

#####################################################BASE DATA EXTRACTION FUNCTIONS###########################################################
def display_all_variables(raw_input_dataframe):
    '''
        A simple wrapper function for getting item names for df.
        :input raw_input_dataframe: A dataframe output by read_raw_file/batch_read_files
        :return: All Item Names contained in raw_input_dataframe
    '''
    return list(set(raw_input_dataframe.Item_Name))

def get_final_values(raw_input_dataframe, metrics = ['_Trial_Counter']):
    '''
        Retrieves the final values for a set of target metrics from a dataframe.
        :param raw_input_dataframe: A dataframe output by read_raw_file/batch_read_files
        :param metrics: A list of labels present in raw_input_dataframe.Item_Name for which to retrieve values.
        :return out_series: A pandas series with index=metrics and values = the latest recorded value of each metric.
    '''
    out_series = pd.Series(index=metrics)
    for metric in metrics:
        metric_idx = raw_input_dataframe[raw_input_dataframe.Item_Name==metric].index
        measure = raw_input_dataframe.loc[metric_idx[-1], 'Arg1_Value']
        out_series.loc[metric] = measure
    return out_series

def concatenate_values_over_days(animal_dictionary, dates, outer_metrics = ['_Trial_Counter']):
    '''
        A function for applying get_final_values to multiple days for a single animal.
        :param animal_dictionary: A dictionary for a single animal with key: date, and 
                                  value: dataframe output by read_raw_file/batch_read_files
        :param dates: A list of keys within animal_dictionary over which to iterate.
        :param outer_metrics: A list of labels present in the target dataframes for which to retrieve values.
        :return cross_day_output: A pandas Series with multi-level index (date, metric) and the last recorded
                                  value of each metric on a given day. 
    '''
    multi_index = pd.MultiIndex.from_product([range(len(dates)), outer_metrics])
    cross_day_output = pd.Series(index = multi_index)
    for day, date in enumerate(dates):
        single_day_performance =  get_final_values(animal_dictionary[date], metrics=outer_metrics)
        cross_day_output.loc[(day, outer_metrics)] = single_day_performance.values
    return cross_day_output

def extract_timestamps(raw_input_dataframe, target, wide=True):
    '''
       Returns all timestamps for a single value within a dataframe. 
       :param raw_input_dataframe: A dataframe output by read_raw_file/batch_read_files
       :param target: Either a single metric or a list of metrics for which to retrieve timestamps.
       :param wide: Toggles whether to return ts_df or ordered_events.
       :return ts_df: A DataFrame with index: indices, columns: targets, and values: timestamps.
       :return ordered_events: A Series with index: timestamps (sorted in ascending order), 
                               and values: metric label from target.
    '''

    # Target may be either a single value or a list
    if isinstance(target, str):
        target = [target] # Turn it into a list for iteration

    max_len = raw_input_dataframe.loc[raw_input_dataframe.Item_Name.isin(target)].shape[0]
    ts_df = pd.DataFrame(index=range(max_len), columns=target)

    for t in target:
        evnt_ts = raw_input_dataframe.loc[raw_input_dataframe.Item_Name==t, 'Evnt_Time'].values
        ts_df.loc[range(evnt_ts.size), t] = evnt_ts

    ts_df.dropna(how='all', axis=0, inplace=True)

    if wide:
        return ts_df
    else:
        long_df = pd.DataFrame(index = range(ts_df.size), columns = ['Time', 'Label'])
        idx_start = 0
        for col in ts_df.columns:
            real_numbers = ts_df.loc[:, col].dropna(how='any', axis=0)
            idx_end = (idx_start + real_numbers.size)-1
            long_df.loc[idx_start:idx_end, 'Time'] = real_numbers.values
            long_df.loc[idx_start:idx_end, 'Label'] = col
            idx_start=idx_end+1

        long_df.dropna(how='any', axis=0, inplace=True)
        ordered_events = pd.Series(index=long_df.Time.astype('float'), data=long_df.Label.values)
        return ordered_events.sort_index()
